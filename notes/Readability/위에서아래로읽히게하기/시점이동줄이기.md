코드를 읽을 때 코드의 위아래를 왔다갔다 하면서 읽거나, 여러 파일이나 함수, 변수를 넘나들면서 읽는 것을 시점 이동이라고 해요. 시점이 여러 번 이동할수록 코드를 파악하는 데에 시간이 더 걸리고, 맥락을 파악하는 데에 어려움이 있을 수 있어요.

코드를 위에서 아래로, 하나의 함수나 파일에서 읽을 수 있도록 코드를 작성하면, 읽는 사람이 동작을 빠르게 파악할 수 있게 돼요.

### 코드 예시

다음 코드에서는 사용자의 권한에 따라서 버튼을 다르게 보여줘요.

- 사용자의 권한이 관리자(Admin)라면, Invite와 View 버튼을 보여줘요.
- 사용자의 권한이 보기 전용(Viewer)이라면, Invite 버튼은 비활성화하고, View 버튼을 보여줘요.

```tsx
function Page() {
  const user = useUser();
  const policy = getPolicyByRole(user.role);

  return (
    <div>
      <Button disabled={!policy.canInvite}>Invite</Button>
      <Button disabled={!policy.canView}>View</Button>
    </div>
  );
}

function getPolicyByRole(role) {
  const policy = POLICY_SET[role];

  return {
    canInvite: policy.includes("invite"),
    canView: policy.includes("view")
  };
}

const POLICY_SET = {
  admin: ["invite", "view"],
  viewer: ["view"]
};
```

### 개선

#### A. 조건을 펼쳐서 그대로 드러내기

요구사항 그대로 코드에 드러내는 방법이다.
Button의 `disabled` prop에 변수를 사용하지 않아서 더 명확하게 보여줄 수 있다.

```ts
function Page() {
  const user = useUser();

  switch (user.role) {
    case "admin":
      return (
        <div>
          <Button disabled={false}>Invite</Button>
          <Button disabled={false}>View</Button>
        </div>
      );
    case "viewer":
      return (
        <div>
          <Button disabled={true}>Invite</Button>
          <Button disabled={false}>View</Button>
        </div>
      );
    default:
      return null;
  }
}
```

#### B. 조건을 한눈에 볼 수 있는 객체로 만들기

```tsx
function Page() {
    const user = useUser();
    const policy = {
        admin: { canInvite: true, canView: true },
        viewer: { canInvite: false, canView: true}
    }[user.role];

    return (
      <Button disabled={!policy.canInvite}>Invite</Button>
      <Button disabled={!policy.canView}>View</Button>
    );
}
```

### 느낀 점

컴포넌트에서 항상 로직이나 조건은 return부 위쪽에, UI는 return부에 정의한다고 암묵적으로 생각했었는데,
개선 방안 A처럼 조건과 함께 직관적으로 사용해도 괜찮은 것 같다.

개발하면서 이리저리 화면을 왔다갔다 하면서 이 함수가 어디있었지 찾을 때가 많았는데
앞으로는 시점 이동을 줄일 수 있도록 리펙토링해봐야겠다.

가독성 또한 코드를 분리하고 나누는 기준이 될 수 있다는 것을 알았다.