### 예시

```tsx
import moment, { Moment } from "moment";
import { useMemo } from "react";
import {
  ArrayParam,
  DateParam,
  NumberParam,
  useQueryParams
} from "use-query-params";

const defaultDateFrom = moment().subtract(3, "month");
const defaultDateTo = moment();

export function usePageState() {
  const [query, setQuery] = useQueryParams({
    cardId: NumberParam,
    statementId: NumberParam,
    dateFrom: DateParam,
    dateTo: DateParam,
    statusList: ArrayParam
  });

  return useMemo(
    () => ({
      values: {
        cardId: query.cardId ?? undefined,
        statementId: query.statementId ?? undefined,
        dateFrom:
          query.dateFrom == null ? defaultDateFrom : moment(query.dateFrom),
        dateTo: query.dateTo == null ? defaultDateTo : moment(query.dateTo),
        statusList: query.statusList as StatementStatusType[] | undefined
      },
      controls: {
        setCardId: (cardId: number) => setQuery({ cardId }, "replaceIn"),
        setStatementId: (statementId: number) =>
          setQuery({ statementId }, "replaceIn"),
        setDateFrom: (date?: Moment) =>
          setQuery({ dateFrom: date?.toDate() }, "replaceIn"),
        setDateTo: (date?: Moment) =>
          setQuery({ dateTo: date?.toDate() }, "replaceIn"),
        setStatusList: (statusList?: StatementStatusType[]) =>
          setQuery({ statusList }, "replaceIn")
      }
    }),
    [query, setQuery]
  );
}
```

### 코드 냄새 맡기

usePageState 훅에서 모든 QueryParams 정보들을 관리하고 있다.
하지만 새로운 QueryParam이 계속 생겨나면 훅의 책임이 무한정 늘어날 수 있다.

그리고 저 QueryParams 중 하나의 값만 바뀌어도
useMemo는 새로운 객체를 만들어 반환하기 때문에 usePageState hooks을 쓰고 있는 컴포넌트들이 모두 리렌더링 된다.

### 개선

```tsx
import { NumberParam, useQueryParam } from "use-query-params";

export function useCardIdQueryParam() {
  const [cardId, _setCardId] = useQueryParam("cardId", NumberParam);

  const setCardId = useCallback((cardId: number) => {
    _setCardId({ cardId }, "replaceIn");
  }, []);

  return [cardId ?? undefined, setCardId] as const;
}
```

쿼리 파라미터 별로 별도의 Hook을 작성하면, 훅 이름도 명확해지고 Hook을 수정해도 영향이 갈 범위가 줄어들어
예상하지 못한 변경을 대비할 수 있다.

### 느낀 점

프로젝트를 둘러보면서 여러가지 역할이 뭉쳐있는 훅이 없는지 확인해봐야겠다.
