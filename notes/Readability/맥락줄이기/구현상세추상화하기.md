https://frontend-fundamentals.com/code-quality/code/examples/login-start-page.html

### Example 1

다음 <LoginStartPage /> 컴포넌트는 사용자가 로그인되었는지 확인하고, 로그인이 된 경우 홈으로 이동시키는 로직을 가지고 있어요.

```ts
function LoginStartPage() {
  useCheckLogin({
    onChecked: (status) => {
      if (status === "LOGGED_IN") {
        location.href = "/home";
      }
    }
  });

  /* ... 로그인 관련 로직 ... */

  return <>{/* ... 로그인 관련 컴포넌트 ... */}</>;
}
```

### Problem

어떻게 고쳐야할 지 잘 감이 안왔지만, 일단 코드가 눈에 잘 안들어왔다.
onChecked는 로그인 요청에 따른 콜백 같긴 하지만, 처음에 딱 봤을 때 뭘 체크한다는 건지 바로 이해가 안됐고 또 LOGGED_IN과 비교를 하니 헷갈렸다.

가장 큰 문제점은 로그인 관련 로직 뿐만 아니라
로그인 결과에 따른 행동까지도 함께 처리하기 때문에 하나의 컴포넌트에 두 가지 책임이 있고, 
따라서 읽는 사람이 고려해야 할 맥락이 많아진다는 것이다.
그냥 LoginStartPage는 로그인 UI를 보여주는 것에 집중시켜보자.


### Improve

#### 옵션 1: Wrapper 사용하기

```ts
function App() {
    return (
        <AuthGuard>
            <LoginStartPage />
        <AuthGuard />
    );
}

function AuthGuard({ children }) {
    const status = useCheckLoginStatus();

    useEffect(() => {
        if (status === "LOGGED_IN") {
            location.href === "/home";
        }
    }, [status]);

    return status !== "LOGGED_IN" ? children : null;
}

function LoginStartPage() {
    /** 로그인 UI만 처리 ... */
    return <>{/* 로그인 관련 컴포넌트 */}</>;
}
```

#### 옵션 2: HOC (Higher-Order Component)
React 컴포넌트를 인자로 받아서 새로운 컴포넌트를 반환하는 함수를 말한다.
함수형 프로그래밍에서 고차 함수 개념을 컴포넌트에 적용한 것이라 보면 된다.

```ts
function LoginStartPage() {
    /** 로그인 UI만 처리 ... */
    return <>{/* 로그인 관련 컴포넌트 */}</>;
}

export defualt withAuthGuard(LoginStartPage);

function withAuthGuard(WrappedComponent) {
    return function AuthGuard(props) {
        const statu = useChckLoginStatus();

        useEffect(() => {
            if (status === "LOGGED_IN") {
                location.href === "/home";
            }
        }, [status]);

        return status !== "LOGGED_IN" ? <WrappedComponent {...props} /> : null;
    }
}

```


### 느낀 점

HOC 패턴을 사용하면 사용하는 쪽에서 그냥 `<LoginStartPage title={...}/>` 이런식으로 사용할 수 있다.
두 가지 방법 모두 좋았고, Wrapper 패턴과 HOC 패턴은 컴포넌트를 추상화 레벨의 차이라는 생각이 들었다.
HOC 패턴도 한번 사용해봐야겠다.


### Example 2

다음 <FriendInvitation /> 컴포넌트는 클릭하면 사용자에게 동의를 받고 사용자에게 초대를 보내는 페이지 컴포넌트예요.

```ts
function FriendInvitation() {
  const { data } = useQuery(/* 생략.. */);

  // 이외 이 컴포넌트에 필요한 상태 관리, 이벤트 핸들러 및 비동기 작업 로직...

  const handleClick = async () => {
    const canInvite = await overlay.openAsync(({ isOpen, close }) => (
      <ConfirmDialog
        title={`${data.name}님에게 공유해요`}
        cancelButton={
          <ConfirmDialog.CancelButton onClick={() => close(false)}>
            닫기
          </ConfirmDialog.CancelButton>
        }
        confirmButton={
          <ConfirmDialog.ConfirmButton onClick={() => close(true)}>
            확인
          </ConfirmDialog.ConfirmButton>
        }
        /* 중략 */
      />
    ));

    if (canInvite) {
      await sendPush();
    }
  };

  // 이외 이 컴포넌트에 필요한 상태 관리, 이벤트 핸들러 및 비동기 작업 로직...

  return (
    <>
      <Button onClick={handleClick}>초대하기</Button>
      {/* UI를 위한 JSX 마크업... */}
    </>
  );
}
```

### Improve

```tsx
export function FriendInvitation() {
  const { data } = useQuery(/* 생략.. */);

  // 이외 이 컴포넌트에 필요한 상태 관리, 이벤트 핸들러 및 비동기 작업 로직...

  return (
    <>
      <InviteButton name={data.name} />
      {/* UI를 위한 JSX 마크업 */}
    </>
  );
}

function InviteButton({ name }) {
  return (
    <Button
      onClick={async () => {
        const canInvite = await overlay.openAsync(({ isOpen, close }) => (
          <ConfirmDialog
            title={`${name}님에게 공유해요`}
            cancelButton={
              <ConfirmDialog.CancelButton onClick={() => close(false)}>
                닫기
              </ConfirmDialog.CancelButton>
            }
            confirmButton={
              <ConfirmDialog.ConfirmButton onClick={() => close(true)}>
                확인
              </ConfirmDialog.ConfirmButton>
            }
            /* 중략 */
          />
        ));

        if (canInvite) {
          await sendPush();
        }
      }}
    >
      초대하기
    </Button>
  );
}
```

### 느낀 점

오히려 onClick 같은 이벤트 메서드를 따로 빼지 않고, 트리거 안에서 작성하는 것이 가독성에 더 도움이 될 수도 있겠다는 것을 배웠다.

또한 `<Button />`이라는 범용적인 컴포넌트에 `<InviteButton name={data.name}/>` 버튼을 씌워 사용하면 재사용에도 좋을 것 같다.

아래 글이 좋아서 가져와봤다.

### 글에서 추상화

"왼쪽으로 10걸음 걸어라" 라고 하는 문장이 있어요. 여기에서

“왼쪽”은 “북쪽을 바라보았을 때 90도 돌아간 위치” 를 추상화한 것이고,
“90도”는 “한 번의 회전을 360등분한 각의 90배만큼 시초선에 대해 시계 반대 방향으로 돌아간 것” 을 추상화한 것이고,
“시계 방향” 의 정의는 “북반구에서 해시계의 바늘이 돌아가는 방향” 을 추상화한 것이에요.
비슷하게 "10걸음", "걸어라"와 같은 단어도 보다 구체적으로 표현할 수 있어요. 그래서 추상화 없이 그대로 문장을 나타낸다면, 다음과 같이 나타낼 수 있을 거예요.

북쪽을 바라보았을 때 한 번의 회전을 360등분한 각의 90배만큼 북반구에서 해시계의 바늘이 돌아가는 방향으로 돌아서, 동물이 육상에서 다리를 이용해 움직이는 가장 빠른 방법보다 느린, 신체를 한 지점에서 다른 지점으로 옮겨가는 행위를 10번 반복해라

이 문장은 그대로 읽었을 때 어떤 의미인지 정확하게 파악하기 어려워요.

### 코드에서 추상화

비슷하게 코드에서도 구현 상세를 지나치게 드러내는 경우, 이 코드가 어떤 역할을 하는지 정확하게 파악하기 어려워요. 한 번에 6~7개 정도의 맥락을 한 번에 고려해 가면서 읽을 수 있도록, 보다 작은 단위로 추상화하는 것이 필요해요.